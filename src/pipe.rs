//
// Copyright (c) The Holo Core Contributors
//
// SPDX-License-Identifier: MIT
//

use std::fmt;
use std::io::{BufRead, BufReader, BufWriter, Read, Write};
use std::process::{Child, Command, Stdio};
use std::thread::JoinHandle;

// ===== type aliases =====

type BuiltinFn = fn(
    args: &[String],
    reader: Box<dyn Read + Send>,
    writer: Box<dyn Write + Send>,
) -> Result<(), String>;

// ===== data types =====

pub enum PipeAction {
    External {
        binary: &'static str,
        fixed_args: &'static [&'static str],
    },
    Builtin(BuiltinFn),
}

pub struct PipeCommand {
    pub name: &'static str,
    pub help: &'static str,
    pub args: &'static [&'static str],
    pub action: PipeAction,
}

pub struct ParsedPipe {
    pub command_idx: usize,
    pub args: Vec<String>,
}

pub struct PipeRegistry {
    commands: Vec<PipeCommand>,
}

#[derive(Debug)]
pub enum PipeError {
    NotFound(String),
    Ambiguous(String, Vec<String>),
    WrongArgCount {
        command: String,
        expected: usize,
        got: usize,
    },
    NotAllowed,
}

enum PipeStage {
    Thread(JoinHandle<Result<(), String>>),
    Process(Child),
}

pub struct PipeChain {
    writer: Option<Box<dyn Write + Send>>,
    stages: Vec<PipeStage>,
    pager: Option<Child>,
}

// ===== impl PipeRegistry =====

impl PipeRegistry {
    pub fn new() -> Self {
        Self {
            commands: Vec::new(),
        }
    }

    pub fn builtin(
        mut self,
        name: &'static str,
        help: &'static str,
        args: &'static [&'static str],
        func: BuiltinFn,
    ) -> Self {
        self.commands.push(PipeCommand {
            name,
            help,
            args,
            action: PipeAction::Builtin(func),
        });
        self
    }

    pub fn external(
        mut self,
        name: &'static str,
        help: &'static str,
        args: &'static [&'static str],
        binary: &'static str,
        fixed_args: &'static [&'static str],
    ) -> Self {
        self.commands.push(PipeCommand {
            name,
            help,
            args,
            action: PipeAction::External { binary, fixed_args },
        });
        self
    }

    pub fn build(self) -> Self {
        self
    }

    pub fn commands(&self) -> &[PipeCommand] {
        &self.commands
    }

    pub fn find(&self, name: &str) -> Result<usize, PipeError> {
        let matches: Vec<usize> = self
            .commands
            .iter()
            .enumerate()
            .filter(|(_, cmd)| cmd.name.starts_with(name))
            .map(|(i, _)| i)
            .collect();

        match matches.len() {
            0 => Err(PipeError::NotFound(name.to_owned())),
            1 => Ok(matches[0]),
            _ => {
                // Check for exact match.
                for &idx in &matches {
                    if self.commands[idx].name == name {
                        return Ok(idx);
                    }
                }
                let names = matches
                    .iter()
                    .map(|&i| self.commands[i].name.to_owned())
                    .collect();
                Err(PipeError::Ambiguous(name.to_owned(), names))
            }
        }
    }

    pub fn parse_pipe(&self, segment: &str) -> Result<ParsedPipe, PipeError> {
        let mut words = segment.split_whitespace();
        let name = words.next().unwrap_or("");
        let idx = self.find(name)?;
        let args: Vec<String> = words.map(|w| w.to_owned()).collect();
        let expected = self.commands[idx].args.len();
        if args.len() != expected {
            return Err(PipeError::WrongArgCount {
                command: self.commands[idx].name.to_owned(),
                expected,
                got: args.len(),
            });
        }
        Ok(ParsedPipe {
            command_idx: idx,
            args,
        })
    }

    pub fn parse_pipes(
        &self,
        segments: &[&str],
    ) -> Result<Vec<ParsedPipe>, PipeError> {
        segments.iter().map(|seg| self.parse_pipe(seg)).collect()
    }
}

// ===== impl PipeError =====

impl fmt::Display for PipeError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            PipeError::NotFound(name) => {
                write!(f, "unknown pipe command: '{}'", name)
            }
            PipeError::Ambiguous(name, matches) => {
                write!(
                    f,
                    "ambiguous pipe command '{}': {}",
                    name,
                    matches.join(", ")
                )
            }
            PipeError::WrongArgCount {
                command,
                expected,
                got,
            } => {
                write!(
                    f,
                    "pipe command '{}' expects {} argument(s), \
                     got {}",
                    command, expected, got
                )
            }
            PipeError::NotAllowed => {
                write!(f, "pipes are not supported for this command")
            }
        }
    }
}

// ===== builtin filters =====

pub fn filter_include(
    args: &[String],
    reader: Box<dyn Read + Send>,
    writer: Box<dyn Write + Send>,
) -> Result<(), String> {
    let pattern = &args[0];
    let reader = BufReader::new(reader);
    let mut writer = BufWriter::new(writer);
    for line in reader.lines() {
        let line = line.map_err(|e| e.to_string())?;
        if line.contains(pattern.as_str()) {
            writeln!(writer, "{}", line).map_err(|e| e.to_string())?;
        }
    }
    Ok(())
}

pub fn filter_exclude(
    args: &[String],
    reader: Box<dyn Read + Send>,
    writer: Box<dyn Write + Send>,
) -> Result<(), String> {
    let pattern = &args[0];
    let reader = BufReader::new(reader);
    let mut writer = BufWriter::new(writer);
    for line in reader.lines() {
        let line = line.map_err(|e| e.to_string())?;
        if !line.contains(pattern.as_str()) {
            writeln!(writer, "{}", line).map_err(|e| e.to_string())?;
        }
    }
    Ok(())
}

pub fn filter_count(
    _args: &[String],
    reader: Box<dyn Read + Send>,
    writer: Box<dyn Write + Send>,
) -> Result<(), String> {
    let reader = BufReader::new(reader);
    let count = reader.lines().count();
    let mut writer = BufWriter::new(writer);
    writeln!(writer, "{}", count).map_err(|e| e.to_string())?;
    Ok(())
}

pub fn filter_no_more(
    _args: &[String],
    reader: Box<dyn Read + Send>,
    mut writer: Box<dyn Write + Send>,
) -> Result<(), String> {
    let mut reader = reader;
    std::io::copy(&mut reader, &mut writer).map_err(|e| e.to_string())?;
    Ok(())
}

// ===== pager =====

pub fn spawn_pager() -> Result<Child, std::io::Error> {
    Command::new("less")
        .arg("-F")
        .arg("-X")
        .stdin(Stdio::piped())
        .spawn()
}

// ===== default registry =====

pub fn default_registry() -> PipeRegistry {
    PipeRegistry::new()
        .builtin(
            "include",
            "Filter lines matching pattern",
            &["pattern"],
            filter_include,
        )
        .builtin(
            "exclude",
            "Remove lines matching pattern",
            &["pattern"],
            filter_exclude,
        )
        .builtin("count", "Count output lines", &[], filter_count)
        .builtin("no-more", "Disable pager", &[], filter_no_more)
        .build()
}

// ===== pipe chain =====

/// Output sink that can be converted to either `Stdio` (for external
/// processes) or `Box<dyn Write + Send>` (for builtin threads).
enum ChainOutput {
    PagerStdin(std::process::ChildStdin),
    PipeWriter(std::io::PipeWriter),
    Terminal,
}

impl ChainOutput {
    fn into_stdio(self) -> Stdio {
        match self {
            ChainOutput::PagerStdin(s) => Stdio::from(s),
            ChainOutput::PipeWriter(w) => Stdio::from(w),
            ChainOutput::Terminal => Stdio::inherit(),
        }
    }

    fn into_writer(self) -> Box<dyn Write + Send> {
        match self {
            ChainOutput::PagerStdin(s) => Box::new(s),
            ChainOutput::PipeWriter(w) => Box::new(w),
            ChainOutput::Terminal => Box::new(std::io::stdout()),
        }
    }
}

impl PipeChain {
    /// Create a PipeChain that only wraps a pager process (no pipe
    /// stages).
    pub fn from_pager(pager: Child) -> Self {
        PipeChain {
            writer: None,
            stages: vec![],
            pager: Some(pager),
        }
    }

    pub fn spawn(
        registry: &PipeRegistry,
        pipes: &[ParsedPipe],
        use_pager: bool,
    ) -> Result<Self, String> {
        let has_no_more = pipes
            .iter()
            .any(|p| registry.commands()[p.command_idx].name == "no-more");
        let should_page = use_pager && !has_no_more;

        let mut stages: Vec<PipeStage> = Vec::new();

        // Determine the final output destination.
        let (mut next_output, pager) = if should_page {
            let mut pager = Command::new("less")
                .arg("-F")
                .arg("-X")
                .stdin(Stdio::piped())
                .spawn()
                .map_err(|e| format!("failed to spawn pager: {}", e))?;
            let stdin = pager.stdin.take().unwrap();
            (ChainOutput::PagerStdin(stdin), Some(pager))
        } else {
            (ChainOutput::Terminal, None)
        };

        // Build the chain backwards (last pipe first).
        for parsed in pipes.iter().rev() {
            let cmd = &registry.commands()[parsed.command_idx];

            // Skip no-more — it's handled by the pager logic.
            if cmd.name == "no-more" {
                continue;
            }

            match &cmd.action {
                PipeAction::External { binary, fixed_args } => {
                    let mut all_args: Vec<&str> = fixed_args.to_vec();
                    for arg in &parsed.args {
                        all_args.push(arg.as_str());
                    }
                    let mut child = Command::new(binary)
                        .args(&all_args)
                        .stdin(Stdio::piped())
                        .stdout(next_output.into_stdio())
                        .spawn()
                        .map_err(|e| {
                            format!("failed to spawn '{}': {}", binary, e)
                        })?;
                    let child_stdin = child.stdin.take().unwrap();
                    next_output = ChainOutput::PipeWriter(
                        // Convert ChildStdin to PipeWriter
                        // via pipe pair.
                        {
                            let (mut reader, writer) = std::io::pipe()
                                .map_err(|e| {
                                    format!("failed to create pipe: {}", e)
                                })?;
                            // Spawn a forwarding thread from
                            // reader to child stdin.
                            let mut child_stdin = child_stdin;
                            stages.push(PipeStage::Thread(std::thread::spawn(
                                move || {
                                    std::io::copy(
                                        &mut reader,
                                        &mut child_stdin,
                                    )
                                    .map_err(|e| e.to_string())?;
                                    Ok(())
                                },
                            )));
                            writer
                        },
                    );
                    stages.push(PipeStage::Process(child));
                }
                PipeAction::Builtin(func) => {
                    let (pipe_reader, pipe_writer) = std::io::pipe()
                        .map_err(|e| format!("failed to create pipe: {}", e))?;
                    let func = *func;
                    let args = parsed.args.clone();
                    let writer_out = next_output.into_writer();
                    let handle = std::thread::spawn(move || {
                        func(&args, Box::new(pipe_reader), writer_out)
                    });
                    next_output = ChainOutput::PipeWriter(pipe_writer);
                    stages.push(PipeStage::Thread(handle));
                }
            }
        }

        Ok(PipeChain {
            writer: Some(next_output.into_writer()),
            stages,
            pager,
        })
    }

    pub fn take_writer(&mut self) -> Option<Box<dyn Write + Send>> {
        self.writer.take()
    }

    pub fn finish(mut self) -> Result<(), String> {
        // Drop writer to signal EOF to the first pipe stage.
        drop(self.writer.take());

        // Wait for all stages (in reverse order — first spawned
        // last).
        for stage in self.stages.drain(..).rev() {
            match stage {
                PipeStage::Thread(handle) => match handle.join() {
                    Ok(result) => result?,
                    Err(_) => {
                        return Err("pipe thread panicked".to_owned());
                    }
                },
                PipeStage::Process(mut child) => {
                    child.wait().map_err(|e| {
                        format!(
                            "failed to wait for pipe process: \
                             {}",
                            e
                        )
                    })?;
                }
            }
        }

        // Wait for pager if present.
        if let Some(mut pager) = self.pager.take() {
            pager
                .wait()
                .map_err(|e| format!("failed to wait for pager: {}", e))?;
        }

        Ok(())
    }
}

// ===== helper functions =====

pub fn split_on_pipes(line: &str) -> (&str, Vec<&str>) {
    let mut parts = line.splitn(2, '|');
    let base = parts.next().unwrap_or("").trim();
    match parts.next() {
        Some(rest) => {
            let pipes: Vec<&str> = rest.split('|').map(|s| s.trim()).collect();
            (base, pipes)
        }
        None => (base, vec![]),
    }
}
