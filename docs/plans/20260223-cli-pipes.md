# CLI Pipe Support

## Overview
- Add pipe (`|`) infrastructure to holo-cli, allowing command output to be filtered and transformed through a chain of pipe commands
- Examples: `show route | include 10.0.0 | exclude bgp`, `show route | count`
- Pipes are only allowed in operational mode (show commands etc.), not in configure mode
- Pipe commands support partial name matching (e.g. `inc` for `include`)

## Context (from discovery)
- 47 callback functions in `internal_commands.rs` — 20 use `YangTableBuilder::show()`, 11 use `page_output()` directly
- Output is currently materialized into `String` or `Table` then passed to `page_output()`/`page_table()` which either prints or pipes through `less`
- `Session` has `use_pager: bool` controlling pager behavior
- `Commands` struct holds the command tree arena
- `CliCompleter` in `terminal.rs` handles tab completion
- No existing pipe/filter infrastructure

## Development Approach
- No test infrastructure exists — skip test-writing steps
- Complete each task fully before moving to the next
- Make small, focused changes
- Run `cargo clippy` and `cargo build` after each task to verify correctness

## Implementation Steps

### Task 1: Create pipe module with registry and data types

**Files:**
- Create: `src/pipe.rs`

- [x] Define `PipeAction` enum with `External { binary, fixed_args }` and `Builtin(fn)` variants
- [x] Define `PipeCommand` struct with `name`, `help`, `args`, `action` fields
- [x] Define `ParsedPipe` struct holding a reference/index to `PipeCommand` + user-provided arg values
- [x] Define `PipeRegistry` struct with `commands: Vec<PipeCommand>`
- [x] Implement builder methods: `new()`, `builtin()`, `external()`, `build()`
- [x] Implement `PipeRegistry::find(&self, name: &str) -> Result<usize, PipeError>` with prefix matching (unique prefix required, ambiguous/not-found errors)
- [x] Implement `PipeRegistry::parse_pipe(&self, segment: &str) -> Result<ParsedPipe, PipeError>` — split segment into words, match first word, capture remaining as args, validate arg count
- [x] Run `cargo clippy && cargo build`

### Task 2: Implement builtin filter functions

**Files:**
- Modify: `src/pipe.rs`

- [x] Implement `filter_include(args, reader, writer)` — line-by-line, keep lines containing pattern
- [x] Implement `filter_exclude(args, reader, writer)` — line-by-line, remove lines containing pattern
- [x] Implement `filter_count(args, reader, writer)` — count lines, write count
- [x] Implement `filter_no_more(args, reader, writer)` — passthrough via `io::copy`
- [x] All use `BufReader`/`BufWriter` for streaming
- [x] Builtin function signature: `fn(&[String], Box<dyn Read + Send>, Box<dyn Write + Send>) -> Result<(), String>`
- [x] Run `cargo clippy && cargo build`

### Task 3: Build the default pipe registry and integrate into Commands

**Files:**
- Modify: `src/pipe.rs`
- Modify: `src/token.rs`
- Modify: `src/main.rs`

- [x] Add `pub fn default_registry() -> PipeRegistry` that builds the registry with include, exclude, count, no-more
- [x] Add `pub pipe_registry: PipeRegistry` field to `Commands` struct
- [x] Initialize `pipe_registry` in `Commands::new()` via `default_registry()`
- [x] Add `mod pipe;` to `main.rs`
- [x] Run `cargo clippy && cargo build`

### Task 4: Implement pipe chain spawning

**Files:**
- Modify: `src/pipe.rs`

- [x] Define `PipeChain` struct holding `Vec<PipeStage>` (enum of `Thread(JoinHandle)` / `Process(Child)`) and the writer end for the callback
- [x] Implement `PipeChain::spawn(pipes: &[ParsedPipe], use_pager: bool) -> Result<PipeChain, String>` that:
  - Determines the final output (pager process stdin if `use_pager` and no `no-more` in chain, otherwise stdout)
  - Builds the chain backwards: for each pipe stage, creates `std::io::pipe()` pairs connecting stages
  - For external pipes: spawns `Command` with stdin/stdout piped, user args appended to fixed_args
  - For builtin pipes: spawns `std::thread::spawn` with reader/writer ends
- [x] Implement `PipeChain::finish(self) -> Result<(), String>` that drops the writer, joins threads, waits processes
- [x] Handle `no-more` flag — when present in chain, skip pager for final output
- [x] Run `cargo clippy && cargo build`

### Task 5: Add Writer abstraction to Session

**Files:**
- Modify: `src/session.rs`

- [x] Add `writer: Option<Box<dyn std::io::Write + Send>>` field to `Session`
- [x] Initialize `writer: None` in `Session::new()`
- [x] Add `pub fn set_writer(&mut self, w: Option<Box<dyn std::io::Write + Send>>)` method
- [x] Add `pub fn writer(&mut self) -> &mut dyn std::io::Write` method — returns `self.writer` if Some, otherwise returns `std::io::stdout()` (store a stdout handle as fallback)
- [x] Add `pub fn take_writer(&mut self) -> Option<Box<dyn std::io::Write + Send>>` for cleanup
- [x] Run `cargo clippy && cargo build`

### Task 6: Input splitting and execution flow in main.rs

**Files:**
- Modify: `src/main.rs`
- Modify: `src/error.rs`

- [x] Add `split_on_pipes(line: &str) -> (&str, Vec<&str>)` function — split on `|` char, trim whitespace on each segment
- [x] Modify `enter_command()` to split input on pipes before parsing
- [x] After parsing base command, if pipes present: check `session.mode().is_operational()`, return error if not
- [x] Parse pipe segments via `pipe_registry.parse_pipes()`
- [x] When pipes present: spawn `PipeChain`, set `session.set_writer()`, call callback, then `PipeChain::finish()`
- [x] When no pipes: keep existing behavior (callback handles its own output)
- [x] Catch `BrokenPipe` errors from callback — treat as `Ok(false)` (non-fatal)
- [x] Add pipe-related error variants to `error.rs` if needed
- [x] Run `cargo clippy && cargo build`

### Task 7: Migrate page_output/page_table callbacks to session.writer()

**Files:**
- Modify: `src/internal_commands.rs`

- [x] Remove `pager()`, `page_output()`, `page_table()` functions
- [x] In `YangTableBuilder::show()`: render table to `session.writer()` instead of calling `page_table()`
- [x] Migrate all 11 `page_output(session, &output)` call sites to `write_output(session, &output)?`
- [x] When no pipes are present, the pager should be set up as the writer before calling the callback (handle in `enter_command()` flow)
- [x] Ensure callbacks that don't use page_output (e.g. `cmd_configure`, `cmd_exit`, `cmd_commit`) are unchanged
- [x] Run `cargo clippy && cargo build`

### Task 8: Add pipe completion to terminal.rs

**Files:**
- Modify: `src/terminal.rs`

- [x] In `CliCompleter::complete()`: detect if input contains `|`
- [x] If after `|`: extract last pipe segment, trim whitespace
- [x] If empty/no word: list all pipe command names with help text as suggestions
- [x] If partial word: prefix-match against pipe command names
- [x] If pipe command matched + space: show expected arg names in UPPERCASE
- [x] The completer needs access to `PipeRegistry` (via `Commands` which is in `Cli`)
- [x] Run `cargo clippy && cargo build`

### Task 9: Handle pager integration for no-pipe case

**Files:**
- Modify: `src/main.rs`
- Modify: `src/internal_commands.rs`

- [x] When no pipes but `use_pager` is true: spawn pager process, set as `session.writer()` before callback, wait for pager after callback
- [x] When no pipes and `use_pager` is false: `session.writer()` returns stdout (default)
- [x] Remove any remaining direct pager spawning from `internal_commands.rs`
- [x] Verify `show` commands work correctly with and without pager
- [x] Run `cargo clippy && cargo build`

### Task 10: Verify and clean up

- [ ] Verify pipe chains work: `show route | include 10.0.0`
- [ ] Verify chained pipes: `show route | include 10.0.0 | exclude bgp`
- [ ] Verify partial match: `show route | inc 10.0.0`
- [ ] Verify error on ambiguous prefix
- [ ] Verify pipes rejected in configure mode
- [ ] Verify `| no-more` disables pager
- [ ] Verify `| count` outputs line count
- [ ] Verify tab completion after `|`
- [ ] Run `cargo clippy && cargo build`
- [ ] Clean up any unused imports or dead code

## Technical Details

### Data structures

```rust
// pipe.rs
pub enum PipeAction {
    External { binary: &'static str, fixed_args: &'static [&'static str] },
    Builtin(fn(&[String], Box<dyn Read + Send>, Box<dyn Write + Send>) -> Result<(), String>),
}

pub struct PipeCommand {
    pub name: &'static str,
    pub help: &'static str,
    pub args: &'static [&'static str],
    pub action: PipeAction,
}

pub struct ParsedPipe {
    pub command_idx: usize,
    pub args: Vec<String>,
}

pub struct PipeRegistry {
    commands: Vec<PipeCommand>,
}

pub struct PipeChain {
    writer: Box<dyn Write + Send>,
    stages: Vec<PipeStage>,
}

enum PipeStage {
    Thread(std::thread::JoinHandle<Result<(), String>>),
    Process(std::process::Child),
}
```

### Default registry

```rust
PipeRegistry::new()
    .builtin("include", "Filter lines matching pattern", &["pattern"], filter_include)
    .builtin("exclude", "Remove lines matching pattern", &["pattern"], filter_exclude)
    .builtin("count", "Count output lines", &[], filter_count)
    .builtin("no-more", "Disable pager", &[], filter_no_more)
    .build()
```

### Execution flow

```
Input: "show route | include 10.0.0 | exclude bgp"
  1. split_on_pipes → ("show route", ["include 10.0.0", "exclude bgp"])
  2. parse_command("show route") → ParsedCommand
  3. check mode is operational → ok
  4. parse pipes → [ParsedPipe{include, ["10.0.0"]}, ParsedPipe{exclude, ["bgp"]}]
  5. spawn chain:
     - final output = pager (if use_pager) or stdout
     - exclude thread: reads from pipe, writes to final output
     - include thread: reads from pipe, writes to exclude stdin
     - chain writer = include stdin
  6. session.set_writer(chain writer)
  7. callback writes to session.writer() → streams through include → exclude → output
  8. drop writer, join threads, wait processes
```

### Pipe matching

Prefix match same as command matching: `name.starts_with(input)`. If multiple matches, error with "ambiguous pipe command". If zero matches, error with "unknown pipe command".

## Post-Completion

**Manual verification:**
- Test with live holod daemon for realistic output
- Test large output sets to verify streaming works (no memory blowup)
- Test broken pipe handling (e.g. `show route | count` where count closes stdin after counting)
